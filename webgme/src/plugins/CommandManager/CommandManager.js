/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Wed Nov 29 2017 13:00:55 GMT-0600 (CST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of CommandManager.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CommandManager.
     * @constructor
     */
    var CommandManager = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    CommandManager.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    CommandManager.prototype = Object.create(PluginBase.prototype);
    CommandManager.prototype.constructor = CommandManager;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CommandManager.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            errors = [],
            activeNode = this.activeNode,
            core = this.core,
            logger = this.logger;

        // promisify require
        function requireP(scriptPath) {
            return new Promise((resolve, reject) => {
                require([scriptPath], resolve);
            });
        }

        // setup socket connection
        function setupSocket(address) {
            return requireP('/socket.io/socket.io.js').then( _io => {
                let socket = _io(address);
                logger.info('finished setting up socket connection.');
                return socket;
            });
        }

        // emits an object through the socket
        function sendCmds(socket, cmds) {
            const MSG_TYPE = 'submission';
            if (errors.length > 0) return; // there are erros
            cmds = cmds
                .filter(cmd => cmd.type === 'Move' || cmd.type === 'Turn')
                .map(cmd => {
                    if (cmd.type === 'Turn') {
                        if (!['left', 'right'].includes(cmd.direction)) handleError('Bad direction.');
                        return cmd.direction;
                    }
                    if (cmd.type === 'Move') {
                        if (cmd.direction === 'forward') return cmd.distance;
                        if (cmd.direction === 'backward') return -1 * cmd.distance;
                        handleError('Bad or missing direction.');
                    }
                });
            socket.emit(MSG_TYPE, cmds);
            console.log('sent commands', cmds);
            logger.info('sent commands', cmds);
        }

        // handle error and give user feedback
        function handleError(msg) {
            console.error(msg);
            logger.info(msg);
            errors.push(msg);
        }

        // returns the targeted robot address
        let getRobotAddress = function(nodes) {
            let node = nodes.find(node => getMetaName(node) === 'ConnectionParameters');
            if (!node) handleError('Connection parameters are not set.');
            let host = core.getAttribute(node, 'robotAddress');
            let port = core.getAttribute(node, 'portNumber');
            if (!host || !port) handleError('Setup connection parameters to robot.');
            return 'http://'+host+':'+port;
        };

        // locate the startNode in a set of nodes
        function findStartNode(nodes) {
            // TODO add start metanode
            let firstNode;
            firstNode = nodes.find(node => getMetaName(node) === 'Start');
            // firstNode = nodes.find(node => core.getAttribute(node, 'name') === 'Start');
            if (!firstNode) handleError('Start node not found.');
            return firstNode;
        };

        // get a node's name
        function getName(node) {
            return core.getAttribute(node, 'name');
        }

        function getMetaName(node) {
            return getName(core.getMetaType(node));
        }


        // describe a node for logging purposes
        function describe(node, log=false) {
            let msg = getName(node);
            msg += ' ' + core.getAttribute(node, 'direction');
            if (log) console.log(msg);
            return msg;
        }

        // turns a node into a simpler object
        function stripNode(node) {
            let metadata = {
                name: getName(node),
                direction: core.getAttribute(node, 'direction'),
                distance: core.getAttribute(node, 'distance'),
                type: getName(core.getBaseType(node))
            };
            if (metadata.distance && metadata.distance > 9) {
                handleError(metadata.name + ' Move distance is over the limit');
            }
            return metadata;
        }

        // check if a nodes is a stop node
        let isStopNode = function(node) {
            return getMetaName(node) === 'Stop';
        };

        // loads the chain of commands in order from srcNode
        function getCommandChain(startNode) {
            let cmdChain = [];
            return new Promise((resolve, reject) => {
                let loadChain = function(srcNode) {
                    if (!srcNode) {
                        reject('trying to load undefined node');
                        return;
                    }

                    if (isStopNode(srcNode)) {
                        cmdChain.forEach(cmd => describe(cmd, true));
                        cmdChain = cmdChain.map(stripNode);
                        resolve(cmdChain);
                        return;
                    }

                    // generalize to check if is a command node
                    if (core.isConnection(srcNode)) {
                        core.loadPointer(srcNode, 'dst', function (err, destNode) {
                            if (err) {
                                handleError(err);
                                // Handle error
                            }
                            // load the destination
                            loadChain(destNode);
                        });
                    } else {
                        // add it to command chain
                        cmdChain.push(srcNode);
                        // Load the nodes with pointers named 'src' to the sourceNode.
                        // (Here the connections that have sourceNode as source.)
                        core.loadCollection(srcNode, 'src', function (err, connNodes) {
                            if (err) {
                                handleError(err);
                            } else {
                                if (connNodes.length > 1) {
                                    reject('more than one connection found.');
                                    return;
                                }
                                // load the next one
                                loadChain(connNodes[0]);
                            }
                        });
                    }
                }; // end of loadChain
                loadChain(startNode);

            });
        } // end of getCommandChain

        // helper to set the results based on the encoutered errors and constraints
        function setResults() {
            if (errors.length > 0) {
                callback(errors.join(', '), self.result);
            } else {
                self.result.setSuccess(true);
                callback(null, self.result);
            }
        }
        
        core.loadSubTree(activeNode, function (err, nodes) {
            errors = [];
            nodes = nodes.filter( node => !core.isConnection(node));
            if (nodes.length < 3) handleError('Add more commands.');

            // find start and follow the chain
            let robotAddress = getRobotAddress(nodes);
            let startNode = findStartNode(nodes);
            // load socket.io and create a socket connection
            let socketPromise = setupSocket(robotAddress);
            let cmdChainPromise = getCommandChain(startNode);
            Promise.all([socketPromise, cmdChainPromise])
                .then(([socket, cmdChain]) => {
                    sendCmds(socket, cmdChain);
                    // TODO handle push updates
                    setResults();
                })
                .catch( err => {
                    handleError(err);
                    setResults(); // no .finally..
                });
        });

    };

    return CommandManager;
});
